name: Deploy TaskMap

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test:ci

      - name: Build application
        run: npm run build

      - name: Write build marker (version.txt)
        run: echo "${GITHUB_SHA}" > dist/version.txt

      - name: Deploy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          # Copy full build output (including nested assets/).
          # Use strip_components to drop the leading "dist/" on the remote.
          source: "dist/**"
          target: "/var/www/task.kanazawa-application-support.jp"
          strip_components: 1
          rm: true

      - name: Copy Nginx config to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          source: "nginx-task.conf"
          # scp-action's `target` is a directory on the remote.
          target: "/tmp"

      - name: Copy server (API) sources to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          source: "server/**"
          target: "/opt/taskmap"

      - name: Setup Docker container and Nginx
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          script: |
            set -e

            DEBUG_LOG="/tmp/taskmap-deploy-debug.txt"
            : > "$DEBUG_LOG"
            # Capture ALL output into debug log (also copied into web root on exit).
            exec >"$DEBUG_LOG" 2>&1
            log() { echo "[$(date -Iseconds)] $*" ; }

            log "Step 0: Detect frontend container"
            CONTAINER="$(docker ps --format '{{.Names}}' | grep -E '^poster-mapping-deploy-frontend' | head -n 1 || true)"
            if [ -z "$CONTAINER" ]; then
              log "ERROR: poster-mapping-deploy-frontend container not found."
              log "Currently running containers:"
              docker ps -a || true
              exit 1
            fi
            log "Using container: $CONTAINER"

            # Always try to publish debug log into the served directory (even if we fail later).
            trap 'docker exec "$CONTAINER" mkdir -p /var/www/task.kanazawa-application-support.jp >/dev/null 2>&1 || true; docker cp "$DEBUG_LOG" "$CONTAINER":/var/www/task.kanazawa-application-support.jp/deploy-debug.txt >/dev/null 2>&1 || true' EXIT

            log "Step 0.5: Detect docker network (from nginx container)"
            # Use the SAME docker network as the nginx(frontend) container, so nginx can resolve taskmap-api by name.
            NET="$(docker inspect "$CONTAINER" --format '{{range $k, $v := .NetworkSettings.Networks}}{{println $k}}{{end}}' | head -n 1 || true)"
            if [ -z "$NET" ]; then
              log "ERROR: Cannot determine docker network for $CONTAINER"
              docker inspect "$CONTAINER" || true
              exit 1
            fi
            log "Using docker network (from nginx container): $NET"

            log "Step 1: Create directory in Docker container"
            docker exec "$CONTAINER" mkdir -p /var/www/task.kanazawa-application-support.jp

            log "Step 2: Copy TaskMap files to Docker container"
            if [ ! -f /var/www/task.kanazawa-application-support.jp/index.html ]; then
              log "ERROR: host build output missing: /var/www/task.kanazawa-application-support.jp/index.html"
              ls -la /var/www/task.kanazawa-application-support.jp || true
              exit 1
            fi
            log "Host index asset refs:"
            grep -n "assets/index-" /var/www/task.kanazawa-application-support.jp/index.html || true
            log "Host version.txt:"
            cat /var/www/task.kanazawa-application-support.jp/version.txt || true
            docker cp /var/www/task.kanazawa-application-support.jp/. "$CONTAINER":/var/www/task.kanazawa-application-support.jp/
            log "Container index asset refs:"
            docker exec "$CONTAINER" sh -c 'grep -n "assets/index-" /var/www/task.kanazawa-application-support.jp/index.html || true'
            log "Container version.txt:"
            docker exec "$CONTAINER" sh -c 'cat /var/www/task.kanazawa-application-support.jp/version.txt || true'
            log "Container assets dir (head):"
            docker exec "$CONTAINER" sh -c 'ls -la /var/www/task.kanazawa-application-support.jp/assets | head -30 || true'

            log "Step 3: Copy Nginx config to Docker container"
            # Keep things simple and robust:
            # - Ensure nginx.conf isn't corrupted (previous runs may have injected literal "\n" or "}include ...")
            # - Place our vhost into /etc/nginx/conf.d where nginx.conf already includes it inside http { }.
            docker exec "$CONTAINER" sh -c 'set -e; CONF=/etc/nginx/nginx.conf; cp -f "$CONF" "$CONF.bak.taskmap.$(date +%s)" || true'
            # Repair common broken states from previous runs (no newline insertion needed):
            docker exec "$CONTAINER" sh -c 'set -e; CONF=/etc/nginx/nginx.conf; sed -i "s/;\\\\n/;/g" "$CONF"; sed -i "s/}include \\/etc\\/nginx\\/conf\\.d\\/\\*\\.conf;$/}/g" "$CONF"; sed -i "s/include \\/etc\\/nginx\\/taskmap\\.d\\/\\*\\.conf;\\\\n//g" "$CONF"; sed -i "s/include \\/etc\\/nginx\\/taskmap\\.d\\/\\*\\.conf;//g" "$CONF"'
            # Remove any previously injected taskmap.d directory (not used anymore)
            docker exec "$CONTAINER" sh -c 'rm -rf /etc/nginx/taskmap.d 2>/dev/null || true'
            docker cp /tmp/nginx-task.conf "$CONTAINER":/etc/nginx/conf.d/00-task.kanazawa-application-support.jp.conf

            log "Step 4: Show nginx.conf include hints"
            docker exec "$CONTAINER" sh -c 'echo "--- /etc/nginx/nginx.conf (head) ---"; head -120 /etc/nginx/nginx.conf || true; echo "--- include lines ---"; grep -n "include" /etc/nginx/nginx.conf || true; echo "--- /etc/nginx/conf.d ---"; ls -la /etc/nginx/conf.d || true'

            log "Step 5: Ensure TLS certificate exists (Let's Encrypt)"
            DOMAIN="task.kanazawa-application-support.jp"
            NEED_ISSUE=0
            if ! docker exec "$CONTAINER" sh -c "test -f /etc/letsencrypt/live/$DOMAIN/fullchain.pem"; then
              NEED_ISSUE=1
              log "Certificate file not found in container."
            else
              # Don't attempt renewal on every deploy (Let's Encrypt rate limits).
              log "Certificate file exists in container; skipping issuance."
            fi

            if [ "$NEED_ISSUE" -eq 1 ]; then
              log "Issuing/renewing certificate via certbot (docker, using SAME volumes as nginx)..."

              # Determine host mount paths used by the nginx container for letsencrypt + webroot.
              LE_HOST="$(docker inspect "$CONTAINER" --format '{{range .Mounts}}{{if eq .Destination "/etc/letsencrypt"}}{{.Source}}{{end}}{{end}}')"
              WEB_HOST="$(docker inspect "$CONTAINER" --format '{{range .Mounts}}{{if eq .Destination "/var/www/certbot"}}{{.Source}}{{end}}{{end}}')"

              log "Detected mounts:"
              log "  /etc/letsencrypt -> ${LE_HOST:-<not mounted>}"
              log "  /var/www/certbot -> ${WEB_HOST:-<not mounted>}"

              # Fallback to known host paths used by poster-mapping-deploy compose.
              if [ -z "$LE_HOST" ] && [ -d "/opt/poster-mapping-deploy/certbot/conf" ]; then
                LE_HOST="/opt/poster-mapping-deploy/certbot/conf"
                log "Fallback LE_HOST=$LE_HOST"
              fi
              if [ -z "$WEB_HOST" ] && [ -d "/opt/poster-mapping-deploy/certbot/www" ]; then
                WEB_HOST="/opt/poster-mapping-deploy/certbot/www"
                log "Fallback WEB_HOST=$WEB_HOST"
              fi

              if [ -z "$LE_HOST" ] || [ -z "$WEB_HOST" ]; then
                log "ERROR: Cannot determine letsencrypt/webroot volume mounts for certbot."
                log "Please ensure nginx container mounts /etc/letsencrypt and /var/www/certbot, or adjust fallback paths."
                exit 1
              fi

              mkdir -p "$LE_HOST" "$WEB_HOST"
              docker run --rm \
                -v "$LE_HOST:/etc/letsencrypt" \
                -v "$WEB_HOST:/var/www/certbot" \
                certbot/certbot:latest \
                certonly --webroot -w /var/www/certbot -d "$DOMAIN" --cert-name "$DOMAIN" \
                --agree-tos --non-interactive --email "admin@kanazawa-application-support.jp"
            fi

            log "Step 5.5: Show certificate details (debug)"
            docker exec "$CONTAINER" sh -c "ls -la /etc/letsencrypt/live/$DOMAIN || true"
            docker exec "$CONTAINER" sh -c "openssl x509 -in /etc/letsencrypt/live/$DOMAIN/fullchain.pem -noout -subject -issuer -startdate -enddate || true"

            log "Step 6: Test Nginx configuration"
            docker exec "$CONTAINER" nginx -t

            log "Step 7: Reload Nginx"
            docker exec "$CONTAINER" nginx -s reload

            echo "Step 7.5: (non-fatal) Ensure taskmap DB/API are running"
            # NOTE: We keep the static deploy green even if API build/run fails.
            if ! docker ps --format '{{.Names}}' | grep -q '^taskmap-db$'; then
              echo "Starting taskmap-db..."
              docker rm -f taskmap-db >/dev/null 2>&1 || true
              if ! docker run -d --name taskmap-db --network "$NET" \
                -e POSTGRES_USER=taskmap -e POSTGRES_PASSWORD=taskmap -e POSTGRES_DB=taskmap \
                -v taskmap_db_data:/var/lib/postgresql/data \
                postgres:16; then
                echo "WARN: failed to start taskmap-db"
              fi
            fi

            # Best-effort wait for DB readiness (don't fail the deploy if it never becomes ready)
            if docker ps --format '{{.Names}}' | grep -q '^taskmap-db$'; then
              echo "Waiting for taskmap-db to be ready..."
              for i in $(seq 1 30); do
                docker exec taskmap-db pg_isready -U taskmap -d taskmap >/dev/null 2>&1 && break
                sleep 1
              done
              docker exec taskmap-db pg_isready -U taskmap -d taskmap || true
            fi

            # Build & run API (Fastify) from /opt/taskmap/server (best-effort)
            if [ ! -d /opt/taskmap/server ]; then
              echo "WARN: /opt/taskmap/server not found (scp failed?)"
            else
              echo "Building taskmap-api..."
              docker rm -f taskmap-api >/dev/null 2>&1 || true
              if ! docker build -t taskmap-api:latest /opt/taskmap/server; then
                echo "WARN: docker build failed for taskmap-api"
              else
                echo "Starting taskmap-api..."
                if ! docker run -d --name taskmap-api --network "$NET" \
                  -e DATABASE_URL="postgresql://taskmap:taskmap@taskmap-db:5432/taskmap" \
                  -e PORT=8080 -e HOST=0.0.0.0 \
                  -e JWT_SECRET="${JWT_SECRET:-dev-secret}" \
                  taskmap-api:latest; then
                  echo "WARN: docker run failed for taskmap-api"
                fi
                docker ps --format '{{.Names}}\t{{.Status}}' | grep -E '^taskmap-api' || true
                docker logs taskmap-api --tail 200 || true
              fi
            fi

            echo "Step 8: Verify deployment"
            echo "Files in container:"
            docker exec "$CONTAINER" ls -la /var/www/task.kanazawa-application-support.jp/ | head -5

            echo "Index.html first 3 lines:"
            docker exec "$CONTAINER" head -3 /var/www/task.kanazawa-application-support.jp/index.html

            echo "Assets directory (should exist):"
            docker exec "$CONTAINER" sh -c 'if [ -d /var/www/task.kanazawa-application-support.jp/assets ]; then ls -la /var/www/task.kanazawa-application-support.jp/assets | head -5; else echo "MISSING: /var/www/task.kanazawa-application-support.jp/assets"; fi'

            echo "Index.html title (should be Task Map):"
            docker exec "$CONTAINER" sh -c 'grep -n "<title>" /var/www/task.kanazawa-application-support.jp/index.html | head -3 || true'

            echo "Nginx config check:"
            docker exec "$CONTAINER" nginx -T 2>&1 | grep -A 5 "server_name task.kanazawa-application-support.jp" | head -10 || true

            echo "Deployment completed successfully!"

      - name: Verify public HTTPS certificate
        run: |
          set -e
          DOMAIN="task.kanazawa-application-support.jp"
          echo "Checking public TLS certificate for $DOMAIN ..."
          echo | openssl s_client -connect "$DOMAIN:443" -servername "$DOMAIN" -showcerts 2>/dev/null | openssl x509 -noout -subject -issuer -startdate -enddate
          echo "HTTP status/redirects:"
          curl -sS -I "https://$DOMAIN/" | head -20
